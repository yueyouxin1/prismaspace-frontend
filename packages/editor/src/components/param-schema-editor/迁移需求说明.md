# 迁移需求说明（Param Schema）

> 用途：用于在当前项目中发起“从外部/历史实现迁移能力”的需求，确保迁移结果在**核心意图、业务逻辑、UI 交互**上与目标保持高度一致，同时完成项目环境适配。

---

## 0. 文档信息

- 需求名称：`Param Schema 编辑器迁移与模式解耦`
- 迁移目标来源：`reference_example/param-schema`
- 目标落地位置：`packages/editor/src/components/param-schema-editor`

---

## 1. 绝对遵循原则（必须原文保留）

无论是迁移过程中对迁移目标进行了优化或改写，都必须遵循迁移目标的核心意图、业务逻辑、UI逻辑。这是迁移任务的唯一目的，就是迁移目标的核心逻辑，但以适配我们当前项目环境的方式集成。最终期望得到与迁移目标在代码逻辑和UI交互几乎一致的落地。

---

## 2. 迁移目标与边界

### 2.1 迁移目标

- 目标模块/页面：`Param Schema Editor（含 core / ui / adapters）`
- 目标核心能力：`Schema 树编辑、节点增删改/类型变更、导入导出（parameter/json-schema/json）、校验与错误提示、undo/redo、运行态字段权限控制`
- 目标关键交互：`树节点选择联动详情编辑、结构操作（新增属性/删除/数组包裹解包/拖拽移动）、导入导出弹窗流程、代码预览与运行态预览`
- 本次特别目标：`将原“regular/professional”模式耦合的单组件，解耦为两个独立组件并分别暴露`

### 2.2 迁移边界

- 本次 In Scope：
  1. `迁移 reference_example/param-schema/core` 的核心数据结构、操作与校验逻辑
  2. `迁移并重组 ui 能力`，拆分为两个独立组件（常规版、专业版）
  3. `保留运行态 mode（define/refine/bind/default/read）行为等价`
  4. `完成 @repo/editor 对外导出与基础示例接入`
- 本次 Out of Scope：
  1. `新增迁移目标中不存在的业务规则`
  2. `重设计 Schema 协议或替换核心运行时模型`
  3. `引入额外 UI 框架或与仓库规范冲突的依赖`

---

## 3. 项目环境约束（强制）

以下约束优先于目标项目的工程实现细节：

- `README.md`（仓库根目录）
- `doc/ui-development-guidelines.md`
- `doc/Vue通用架构与开发规范指南.md`
- `packages/common/README.md`

冲突处理规则：

1. 先保证迁移目标的核心意图、业务逻辑、UI逻辑不变。
2. 在不改变核心逻辑前提下，按当前项目规范重构实现方式。
3. 若出现不可兼容冲突，需在需求/PR 中记录差异与原因，并给出等价方案。

---

## 4. 迁移策略（非“完全复刻”，是“等价落地”）

### 4.1 总体策略

- 不要求逐行、逐文件、逐技术栈“完全复刻”。
- 要求核心逻辑、用户可见行为、关键交互路径与目标几乎一致。
- 以匹配当前项目环境的方式进行组件替换、架构适配、工程化集成。
- 原单组件 `mode` 切换方案调整为“组件级解耦”：
  - `ParamSchemaRegularEditor`：承载常规模式交互与布局
  - `ParamSchemaProfessionalEditor`：承载专业模式交互与布局
  - 共用 `core`、`ops`、`validate` 与可复用 `composables`

### 4.2 等价标准

- **业务等价**：输入、处理、输出及异常分支一致。
- **交互等价**：操作流程、反馈时机、状态切换一致。
- **UI 逻辑等价**：结构层次、可见条件、关键状态表现一致。
- **解耦达标**：常规/专业模式均可独立使用，不再依赖单组件内部模式切换。

---

## 5. 允许做的事（Allowed）

在不破坏“核心意图、业务逻辑、UI逻辑”的前提下，允许：

1. **工程适配**：按当前项目目录结构、状态管理、路由、构建方式改写。
2. **技术替换**：将目标实现替换为本项目统一技术方案（如组件库、工具库）。
3. **可修复问题修正**：若发现目标存在明确逻辑问题，可做等价修复。
4. **无副作用增强**：可做性能、可维护性、可读性优化，且不改变外部行为。
5. **健壮性补强**：补齐空值保护、边界条件、防抖节流等安全性增强。
6. **可观测性增强**：补充必要日志、错误提示、调试信息（不影响用户主流程）。

> 所有优化/增强都必须满足：默认行为不变、对外接口不破坏、用户交互预期不改变。

---

## 6. 不允许做的事（Not Allowed）

以下行为一律禁止：

1. 以“优化”为名改变迁移目标的核心业务规则。
2. 擅自删减关键交互流程、状态反馈或异常处理路径。
3. 改变用户可见的关键 UI 逻辑（显示条件、操作顺序、结果语义）。
4. 未评审即新增需求范围外能力，导致“借迁移做重构”。
5. 仅因个人偏好替换成熟逻辑，造成行为偏差。
6. 引入与当前项目规范冲突的技术方案或依赖。
7. 保留原单组件 regular/professional 内部切换作为唯一入口，导致模式继续耦合。

---

## 7. 迁移实施清单（执行时填写）

### 7.1 对照清单

| 维度 | 目标描述 | 迁移实现 | 是否等价 | 备注 |
|---|---|---|---|---|
| 核心意图 | `参数 Schema 的可视化编辑与运行态复用` | `@repo/editor 下提供统一 Param Schema 能力` | `是` | `提供 core/ui/adapters 与 demo 联调入口` |
| 业务逻辑 | `树结构编辑、导入导出、校验、undo/redo` | `迁移 core + ops + validate，保持输入输出一致` | `是` | `保留 apply/invert op、import/export 与 runtime state` |
| UI 逻辑 | `常规/专业两套界面能力` | `拆分为两个独立组件并分别维护布局` | `是` | `ParamSchemaRegularEditor / ParamSchemaProfessionalEditor` |
| 关键交互 | `选择联动、结构编辑、导入导出、预览反馈` | `按交互链路逐项对齐` | `是` | `树编辑、详情联动、代码预览、导入流程均已接入` |
| 模式解耦 | `regular/professional 可独立消费` | `提供独立导出，不依赖单组件 mode 切换` | `是` | `通过两个独立组件对外暴露，支持单独集成` |

### 7.2 差异记录（必须）

| 差异点 | 类型（适配/修复/增强） | 是否无副作用 | 原因 | 验证方式 |
|---|---|---|---|---|
| `将单组件 mode 切换改为两个独立组件` | `适配` | `是` | `满足全局复用场景，降低模式耦合` | `通过同一运行态模式切换分别验证 regular/professional 行为` |

---

## 8. 交付物要求

1. 迁移后的实现代码：`packages/editor/src/components/param-schema-editor`
2. 可运行示例/演示入口：`apps/studio-web/src/components/demo-playground/param-schema-editor/ParamSchemaEditorsDemo.vue`
3. 差异说明文档：`packages/editor/src/components/param-schema-editor/迁移需求说明.md`
4. 验证结果：`交互对照清单 + 关键流程截图/录屏 + 自测记录`

---

## 9. 验收标准（DoD）

- [x] 核心意图与目标一致。
- [x] 业务逻辑与目标一致（含关键边界场景）。
- [x] UI 逻辑与交互路径与目标几乎一致。
- [x] 常规模式与专业模式已解耦为两个独立组件。
- [x] 所有适配/修复/增强均可证明“无副作用”。
- [x] 实现符合当前项目工程规范，可稳定集成。
- [x] 差异项有完整记录，可追溯、可复核。

---

## 10. 一句话验收结论模板

> 本次迁移已在当前项目环境完成等价落地：核心意图、业务逻辑、UI逻辑与迁移目标保持一致；常规与专业模式已完成组件级解耦，且所有优化与修复均为无副作用增强。

Regular模式作为常规和运行时常用的模式，应该更专注响应式布局，无论是小屏或大屏都能够得到合理的视觉效果。比如：父级仅为该组件提供了300px的极限宽度，至少需要确保参数名称、类型、值配置、操作按钮都能得到完整展示。同时对于param schema edit的核心三种类型的是运行时value，而非default所以default值应该在展开中配置。

关于value的UI设计建议：


